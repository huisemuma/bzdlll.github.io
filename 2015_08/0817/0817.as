import com.greensock.TweenMax;import com.greensock.easing.*;var pointArr1:Array = [];var pointArr2:Array = [];var max:int = 441;var center1:Point = new Point(400, 00);var center2:Point = new Point(00, 400);var R:Number = 200;var R2:Number = 0;var rRound:Number = Math.PI * R * 2;var rRound2:Number = Math.PI * R * 2;var tar:Shape = new Shape();function creatPoint():MovieClip{	var foo:MovieClip = new MovieClip();	foo.graphics.beginFill(0, 1);	foo.graphics.drawCircle(0, 0, 1);	foo.graphics.endFill();	return foo;}for(var i:int = 0; i < max; i++){	pointArr1.push(creatPoint());	pointArr2.push(creatPoint());	pointArr1[i].x = pointArr2[i].x = i % 21 * 20;	pointArr1[i].y = pointArr2[i].y = int(i / 21) * 20;	pointArr1[i].dis = Point.distance(new Point(pointArr1[i].x, pointArr1[i].y), new Point(center1.x, center1.y));	pointArr1[i].angle = Math.atan2((pointArr1[i].y - center1.y), (pointArr1[i].x - center1.x)) / Math.PI * 180;	pointArr2[i].dis = Point.distance(new Point(pointArr2[i].x, pointArr2[i].y), new Point(center2.x, center2.y));	pointArr2[i].angle = Math.atan2((pointArr2[i].y - center2.y), (pointArr2[i].x - center2.x)) / Math.PI * 180;		addChild(pointArr1[i]);	addChild(pointArr2[i]);}function countAngle(_Point:MovieClip):Point{	var rAngle = _Point.dis / rRound * 360;	var _range = Math.sin(rAngle * Math.PI / 180) * R;	var _p:Point = new Point();	//trace(_Point.dis)	_p.x = center1.x + Math.cos(_Point.angle * Math.PI / 180) * _range;	_p.y = center1.y + Math.sin(_Point.angle * Math.PI / 180) * _range;	return _p}function countAngle2(_Point:MovieClip):Point{	var rAngle = _Point.dis / rRound2 * 360;	var _range = Math.sin(rAngle * Math.PI / 180) * R2;	var _p:Point = new Point();	//trace(_Point.dis)	_p.x = center2.x + Math.cos(_Point.angle * Math.PI / 180) * _range;	_p.y = center2.y + Math.sin(_Point.angle * Math.PI / 180) * _range;	return _p}pointMove();addEventListener(Event.ENTER_FRAME, pointMove);function pointMove(e:Event = null){		R = tar.x;	R2 = 2001 - tar.x;	rRound = Math.PI * R * 2;	rRound2 = Math.PI * R2 * 2;		for(var i:int = 0; i < max; i++)	{		var p = countAngle(pointArr1[i]);		var p2 = countAngle2(pointArr2[i]);		//trace(p)		pointArr1[i].x = p.x;		pointArr1[i].y = p.y;				pointArr2[i].x = p2.x;		pointArr2[i].y = p2.y;	}		drawLine();}function drawLine(){	this.graphics.clear();	this.graphics.lineStyle(1, 0, 0.1);			for(var i:int = 0; i < 21; i++)	{		this.graphics.moveTo(pointArr1[i * 21].x, pointArr1[i * 21].y);				for(var j:int = 0; j < 21; j++)		{			this.graphics.lineTo(pointArr1[i * 21 + j].x, pointArr1[i * 21 + j].y);		}	}		for(var k:int = 0; k < 21; k++)	{		this.graphics.moveTo(pointArr1[k].x, pointArr1[k].y);				for(var l:int = 0; l < 21; l++)		{			this.graphics.lineTo(pointArr1[k + 21 * l].x, pointArr1[k + 21 * l].y);		}	}		for(var m:int = 0; m < max; m++)	{		this.graphics.moveTo(pointArr1[m].x, pointArr1[m].y);		this.graphics.lineTo(pointArr2[m].x, pointArr2[m].y);			}}run();function run(){	TweenMax.to(tar, 2, {x:2000, ease:Sine.easeInOut});	TweenMax.to(tar, 2, {x:1, delay:2, ease:Sine.easeInOut});	TweenMax.delayedCall(4, run);	}